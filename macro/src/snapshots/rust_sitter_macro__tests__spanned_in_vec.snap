---
source: macro/src/lib.rs
expression: "rustfmt_code(&expand_grammar(parse_quote! {\n                            #[rust_sitter :: grammar(\"test\")] mod grammar\n                            {\n                                use rust_sitter :: Spanned ; #[rust_sitter :: language] pub\n                                struct NumberList { numbers : Vec < Spanned < Number >>, }\n                                pub struct Number\n                                {\n                                    #[rust_sitter ::\n                                    leaf(pattern = r\"\\d+\", transform = | v |\n                                    v.parse().unwrap())] v : i32\n                                } #[rust_sitter :: extra] struct Whitespace\n                                {\n                                    #[rust_sitter :: leaf(pattern = r\"\\s\")] _whitespace : (),\n                                }\n                            }\n                        }).to_token_stream().to_string())"
---
mod grammar {
    use rust_sitter::Spanned;
    pub struct NumberList {
        numbers: Vec<Spanned<Number>>,
    }
    impl rust_sitter::Extract<NumberList> for NumberList {
        type LeafFn = ();
        #[allow(non_snake_case)]
        fn extract(
            node: Option<rust_sitter::tree_sitter::Node>,
            source: &[u8],
            last_idx: usize,
            _leaf_fn: Option<&Self::LeafFn>,
        ) -> Self {
            let node = node.unwrap();
            #[allow(non_snake_case)]
            #[allow(clippy::unused_unit)]
            fn extract_NumberList_numbers(
                cursor_opt: &mut Option<rust_sitter::tree_sitter::TreeCursor>,
                source: &[u8],
                last_idx: &mut usize,
            ) -> Vec<Spanned<Number>> {
                rust_sitter::__private::extract_field(
                    cursor_opt,
                    last_idx,
                    "numbers",
                    move |node, last_idx| {
                        <Vec<Spanned<Number>> as rust_sitter::Extract<_>>::extract(
                            node, source, *last_idx, None,
                        )
                    },
                )
            }
            #[allow(non_snake_case)]
            fn extract_NumberList(
                node: rust_sitter::tree_sitter::Node,
                source: &[u8],
            ) -> NumberList {
                rust_sitter::__private::extract_struct_or_variant(node, move |cursor, last_idx| {
                    NumberList {
                        numbers: extract_NumberList_numbers(cursor, source, last_idx),
                    }
                })
            }
            extract_NumberList(node, source)
        }
    }
    pub struct Number {
        v: i32,
    }
    impl rust_sitter::Extract<Number> for Number {
        type LeafFn = ();
        #[allow(non_snake_case)]
        fn extract(
            node: Option<rust_sitter::tree_sitter::Node>,
            source: &[u8],
            last_idx: usize,
            _leaf_fn: Option<&Self::LeafFn>,
        ) -> Self {
            let node = node.unwrap();
            #[allow(non_snake_case)]
            #[allow(clippy::unused_unit)]
            fn extract_Number_v(
                cursor_opt: &mut Option<rust_sitter::tree_sitter::TreeCursor>,
                source: &[u8],
                last_idx: &mut usize,
            ) -> i32 {
                rust_sitter::__private::extract_field(
                    cursor_opt,
                    last_idx,
                    "v",
                    move |node, last_idx| {
                        <rust_sitter::WithLeaf<i32> as rust_sitter::Extract<_>>::extract(
                            node,
                            source,
                            *last_idx,
                            Some(&|v| v.parse().unwrap()),
                        )
                    },
                )
            }
            #[allow(non_snake_case)]
            fn extract_Number(node: rust_sitter::tree_sitter::Node, source: &[u8]) -> Number {
                rust_sitter::__private::extract_struct_or_variant(node, move |cursor, last_idx| {
                    Number {
                        v: extract_Number_v(cursor, source, last_idx),
                    }
                })
            }
            extract_Number(node, source)
        }
    }
    struct Whitespace {
        _whitespace: (),
    }
    impl rust_sitter::Extract<Whitespace> for Whitespace {
        type LeafFn = ();
        #[allow(non_snake_case)]
        fn extract(
            node: Option<rust_sitter::tree_sitter::Node>,
            source: &[u8],
            last_idx: usize,
            _leaf_fn: Option<&Self::LeafFn>,
        ) -> Self {
            let node = node.unwrap();
            #[allow(non_snake_case)]
            #[allow(clippy::unused_unit)]
            fn extract_Whitespace__whitespace(
                cursor_opt: &mut Option<rust_sitter::tree_sitter::TreeCursor>,
                source: &[u8],
                last_idx: &mut usize,
            ) -> () {
                rust_sitter::__private::extract_field(
                    cursor_opt,
                    last_idx,
                    "_whitespace",
                    move |node, last_idx| {
                        <() as rust_sitter::Extract<_>>::extract(node, source, *last_idx, None)
                    },
                )
            }
            #[allow(non_snake_case)]
            fn extract_Whitespace(
                node: rust_sitter::tree_sitter::Node,
                source: &[u8],
            ) -> Whitespace {
                rust_sitter::__private::extract_struct_or_variant(node, move |cursor, last_idx| {
                    Whitespace {
                        _whitespace: extract_Whitespace__whitespace(cursor, source, last_idx),
                    }
                })
            }
            extract_Whitespace(node, source)
        }
    }
    extern "C" {
        fn tree_sitter_test() -> rust_sitter::tree_sitter::Language;
    }
    pub fn language() -> rust_sitter::tree_sitter::Language {
        unsafe { tree_sitter_test() }
    }
    pub fn parse(
        input: &str,
    ) -> core::result::Result<NumberList, Vec<rust_sitter::errors::ParseError>> {
        let mut parser = rust_sitter::tree_sitter::Parser::new();
        parser.set_language(language()).unwrap();
        let tree = parser.parse(input, None).unwrap();
        let root_node = tree.root_node();
        if root_node.has_error() {
            let mut errors = vec![];
            rust_sitter::errors::collect_parsing_errors(&root_node, input.as_bytes(), &mut errors);
            Err(errors)
        } else {
            use rust_sitter::Extract;
            Ok(<NumberList as rust_sitter::Extract<_>>::extract(
                Some(root_node),
                input.as_bytes(),
                0,
                None,
            ))
        }
    }
}

